== 分布式互斥
董严 <service@istart.studio>
v2.0, February 2015:


====


[preface]
----------

- 临界区问题
- 解决分布式互斥问题的解决方案：基于消息传送的解决方案
- 这种解决方案独立于特定的资源管理方案，下面会具体描述其算法
- 部分算法后在还会进一步描述

----------

[NOTE]
有些应用场景是没有服务器的，且需要协调它们（一对进程）对共享资源的访问。这种情况经常出现在以太网、"自组织"模式的IEEE 802.11 无线网等网络中，其中网络接口作为对等成分进行协作，使得在共享介质上一次只有一个节点进行传输。

[NOTE]
简单的解决方案是这些进程只要通过互相通信就能互斥，就能不需要服务器。

- NFS文件服务器是无状态的，因此不支持文件加锁
- UNIX系统提供由locked（守护进程）实现的一个文件加锁服务。

====

=== 互斥算法

====
假设：

- 无共享变量的N个进程p~i~(i=1,2,···,N)的系统。这些进程只在限定区内访问公共资源。
- 只有一个限定区。一个就够了，完成后就可以扩展到其他限定区。
- 系统是异步的，进程不出故障，消息传递是可靠的。这样的传递的任何消息最终都被完整地恰好发送一次。

限定区的应用层协议：
----
enter() //进入限定区——如果有必要，可以阻塞进入
resourceAccesses() //在限定区反问共享资源
exit() //离开限定区——其他进程现在也可以进入
----

对互斥的基本要求：

- ME1：（安全性） 在限定区（CS）一次最多有一个进程可以执行

- ME2：（活性）进入和离开限定区的请求最终成功执行。既无饥饿也无死锁

- ME3：（顺序）如果进入CS请求在先，那么进入cs也是这个顺序。

[TIP]
没有饥饿问题是一个公平性条件。

[TIP]
进程进入限定区的顺序也是一个公平性问题。不可能按照请求的时间决定顺序，因为没有全局时钟。可以用进入限定区之间的发生在先顺序。


互斥性能标准：

- 消耗的带宽（bandwidth），与在每个entry和exit操作中发送的消息数成比例
- 每次entry和exit操作由进程导致的客户延迟
- 算法对系统吞吐量的影响。假设一组进程之间通讯是必要的，一组进程作为一个整体访问限定区的比率。通过一个进程离开限定区到下一个进程进入到限定区之间的同步延迟（synchronization delay）来衡量这个影响。同步延迟较短时，吞吐量较大。


====

==== 中央服务器算法

====
这是最简单的方法，使用一个服务器授予进入限定区的许可。

----
1. 请求令牌
2. 释放令牌
3. 授予令牌

等待进程队列：先进（请求顺序）先出（移除并授予该进程令牌）
----

此算法满足ME1，ME2，不满足ME3。

性能：

- 一个进程要进入限定区需要两个消息，请求和授权。因为往返时间而使请求进程延迟。
- 离开限定区需要发送一个释放（release）消息。采用异步消息传递，就不会对离开的进程造成延迟。
- 服务器成为系统的瓶颈。同步延迟是下面两个消息往返一次要花费的时间：
 * 发到服务器的释放消息
 * 随后让下一进程进入限定区的授权消息

====

==== 基于环的算法
====
N个进程中安排互斥而不需其他进程的简单方法之一：将这些进程放到一个逻辑环中。这样只要求每个进程P~i~与环中下一个进程P~(i+1)modN~有一个通讯通道。

----
通过获得在进程间沿着环单向（顺时针/逆时针）传递的消息为形式的令牌来实现互斥。
----

环拓扑结构可以与物理结构互连无关

满足ME1，ME2，令牌不必按照发生在先顺序获得

性能：

- 会不断消耗网络带宽（当一个进程在限定区中时除外）：进程需要不断沿着环发送消息，即使进程不需要令牌。
- 进入到获取0～N个消息传输。
- 在一个进程离开和下一个进程进入限定区之间的同步延迟是1～N个消息传输

====
