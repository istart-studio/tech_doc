= Failure assumptions and failure detectors

== 故障假设与故障检测器





----------

- 熟悉故障检测器有助于了解分布式系统中故障的本质
- 如何判断进程何时已经崩溃

----------


*首先*，为了便于理解及阐述，做如下假设：

* 每对进程都通过可靠的通讯连接（尽管底层网络组件可能出现故障，但进程使用能屏蔽故障的可靠通讯协议）。
* 进程故障不隐含对其他进程的通信能力的威胁（没有进程依赖于其他进程来转发消息）。
* 进程只在崩溃时出的故障（这个假定对与很多系统来说足够来）

WARNING: 一个可靠的通讯连接*最终*将消息传递到接收者的输入缓存区。在同步系统中，假设在必要的地方有硬件冗余，一遍底层出故障的时候，可靠通道不仅最终传递每个消息，而且是在指定时间内完成传递工作。


.名词诠释
[width="100%",options="header,footer"]
|====================
|中文|英文|定义
|网络分区|network partition|每个网络内的进程可以通信，但两对进程在路由故障的时候不可能通讯
|非对称的|asymmetric|从进程P到进程Q可以通讯，但反之则不行
|非传递的|-|从进程P可以到进程Q，进程Q可以到R，但从P到R则不行
|故障检测器|failure detector|是一个服务，用于处理有关某个进程是否已经出现故障的查询。通常由每个进程中的一个对象实现，此对象与其他进程的对应部分一起执行一个故障检测算法。
|不可靠故障检测器|unreliable failure detector|可能精确的反应进程是否出故障
|可靠故障检测器|reliable failure detector|精确的反应进程是否出故障
|====================

== 不可靠故障检测器



.产出结果
[width="100%",options="header,footer"]
|====================
|Unsuspected|表示检测器近期已经收到表明进程没有故障的证据
|Suspected|表示故障检测器有迹象表明进程可能已经出故障了
|====================
上面这两种结果可能精确。例如：进程运行比预期的要慢

- 可能怀疑一个没有故障的进程。
- 检测器没有必要精确，大多属于不可靠故障检测器。
- 实现

1. 每个进程P向其他所有进程发送消息"P is here"，每隔T秒发送一次，检测器用最大消息传输时间D秒作为评估值。
2. 如果进程Q的本地故障检测器在最后一次T+D时间内没有收到"P is here"的消息，则向Q报告P是Suspected。
3. 如果后来收到"P is here" 消息，则向Q报告P是OK。


如果为T和D选择了很小的值（1ms），故障检测器会多次怀疑非崩溃的进程，并且大部带宽都会被"P is here"消息占据。
如果为T和D选择很大的值（1d），那么会检测的进程会经常被报告为Unsuspected。

- 优化方案：动态设置网络延迟条件下的超时值（T+D），但检测器仍然是不可靠的，但检测精确的概率增加了

- 在同步系统中，可以使检测器变得更可靠，将D不再作为评估值，而是作为消息传输时间的界限。如果T+D内没有收到消息，则可以得出进程已经崩溃。


== 可靠故障检测器


- 要求是系统同步的，实际中的系统很少是同步的

.产出结果
[width="100%",options="header,footer"]
|====================
|Unsuspected|表示检测器近期已经收到表明进程没有故障的证据
|Failed|表示检测器确定程序已经崩溃
|====================


----------
任何用于应对故障的实际系统都必须检测故障——不管多么不完美。但即使是不可靠，只要它具有良性结构，也能为发生故障时进程协调问题提供解决方案。
----------